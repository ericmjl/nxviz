{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nxviz: Composable and rational network visualizations in matplotlib","text":"<p><code>nxviz</code> is a package for building rational network visualizations using matplotlib as a backend. Inspired heavily by the principles espoused in the grammar of graphics, nxviz provides ways to compose a graph visualization together by adhering to the following recipe:</p> <ol> <li>Prioritize node placement, mapping data to position and visual properties,</li> <li>Draw in edges, mapping data to visual properties,</li> <li>Add in annotations and highlights on the graph.</li> </ol> <p><code>nxviz</code> is simultaneously a data visualization research project, art project, and declarative data visualization tool. We hope you enjoy using it to build beautiful graph visualizations.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#official-releases","title":"Official Releases","text":"<p><code>nxviz</code> is available on PyPI:</p> <pre><code>pip install nxviz\n</code></pre> <p>It's also available on conda-forge:</p> <pre><code>conda install -c conda-forge nxviz\n</code></pre>"},{"location":"#pre-releases","title":"Pre-releases","text":"<p>Pre-releases are done by installing directly from git:</p> <pre><code>pip install git+https://github.com/ericmjl/nxviz.git\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To make a Circos plot:</p> <pre><code># We assume you have a graph G that is a NetworkX graph object.\n# In this example, all nodes possess the \"group\" and \"value\" node attributes\n# where \"group\" is categorical and \"value\" is continuous,\n# and all edges have the \"edge_value\" node attribute as well.\n\nimport nxviz as nv\nax = nv.circos(\n    G,\n    group_by=\"group\",\n    sort_by=\"value\",\n    node_color_by=\"group\",\n    edge_alpha_by=\"edge_value\"\n)\n\nnv.annotate.circos_group(G, group_by=\"group\")\n</code></pre> <p></p> <p>For more examples, including other plots that can be made, please see the examples gallery on the docs.</p>"},{"location":"contributors/","title":"Contributors","text":""},{"location":"contributors/#lead-developers","title":"Lead Developers","text":"<ul> <li>Eric J. Ma (@ericmjl)</li> </ul>"},{"location":"contributors/#code-contributors","title":"Code Contributors","text":"<ul> <li>Nora Kassner  <li>Christian Diener  <li>Thijs Hermans  <li>R. M. Keelan Downton  <li>Maximilian T. Strauss  <li>Brian Cajes (@bcajes)</li> <li>Ashutosh Chandra (@ashu16993)</li> <li>Rabeez Riaz &lt;19100165 (at) lums.edu.pk&gt;</li> <li>Erick Armingol  <li>Walter Hernandez  <li>Eduarda Centeno  <li>Alireza Hosseini  <li>Yashrajsinh Jadeja (@Yashrajsinh-Jadeja)</li> <li>Kelvin Tuong &lt;@zktuong&gt;</li>"},{"location":"history/","title":"Release History","text":""},{"location":"history/#070-2021-xx-xx","title":"0.7.0 (2021-XX-XX)","text":"<ul> <li>Major refactor behind-the-scenes with a functional API.</li> </ul>"},{"location":"history/#037-2018-xx-xx","title":"0.3.7 (2018-XX-XX)","text":"<ul> <li>Node labels in CircosPlot can now be rotated with the <code>rotate_labels</code>   argument.</li> </ul>"},{"location":"history/#036-2018-02-20","title":"0.3.6 (2018-02-20)","text":"<ul> <li>Implemented edge colours, thanks to @noragak.</li> </ul>"},{"location":"history/#035-2018-01-20","title":"0.3.5 (2018-01-20)","text":"<ul> <li>Disabled health checks on certain tests.</li> <li>Added ability to configure plot size.</li> <li>Added docs on preparing a new release.</li> <li>Updated dependencies.</li> </ul>"},{"location":"history/#032-2017-09-18","title":"0.3.2 (2017-09-18)","text":"<ul> <li>All plots except for HivePlot are implemented.</li> <li>Implemented auto-colorbar for plots that have continuous node colors.</li> </ul>"},{"location":"history/#010-2016-07-15","title":"0.1.0 (2016-07-15)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"theory/","title":"How to think about network visualizations","text":"<p>When you're asked to plot a network, is your first instinct to reach for the \"force-directed layout\"? If you try searching for the term on the internet, at first glance it sounds like not a bad idea. But once you try plotting anything with a significant number of nodes (one rule of thumb being 30 nodes or more), the visualization descends into a hairball mess.</p> <p>Ben Sneiderman once said,</p> <p>\"The purpose of visualization is insight, not picture.\"</p> <p>Hairballs, unfortunately, impede our ability to gain insight. Hairballs ultimately end up communicating that everything is connected to everything... and that is highly uninformative. What we need is a structured way of building graph visualizations. Is there a way out of this mess?</p> <p>One answer to the question is yes, and <code>nxviz</code> is intended to be an implementation of network visualizations in Python that guides us network scientists towards thinking clearly about network visualizations. Just as a prism decomposes light into its constituent colours, an effective graph visualization will deconstruct a complex network into interesting structures. Our hope is that <code>nxviz</code> becomes that prism for you.</p>"},{"location":"theory/#grammar-of-graph-visualizations","title":"Grammar of graph visualizations","text":"<p>The key idea espoused in the Grammar of Graphics is that every element in a data visualization should be tied to data. Basically, nothing in a plot should be styled, shaped, or placed without data backing it.</p> <p>When we follow a grammar of graphics, we gain a framework to think about data visualization in general. In some senses, a grammar of graph visualizations is a subset of a grammar of graphics. What are the components of this grammar, or in other words, the rules by which we compose together a network visualization? Let's try to make sense of it.</p>"},{"location":"theory/#prioritize-node-placement","title":"Prioritize node placement","text":"<p>The first step out of hairball hell is to think clearly about where we want to place the nodes. Why? This is because nodes usually correspond to entities that sometimes can be grouped and sorted. For example, if a graph is constructed between people, then we may wish to group them by some categorical property (e.g. their hometown or school), and perhaps sort them by some quantitative or ordinal property (e.g. their age or time of entry into a venue). If exact spatial placement is not meaningful but relative spatial placement is, then we might choose to place the nodes along some line segment, such as a line, or a circle.</p>"},{"location":"theory/#map-node-metadata-to-visual-properties","title":"Map node metadata to visual properties","text":"<p>The node placement step brings us a major step out of hairball hell! Once we are done with node placement, we can go on to style the nodes in a data-driven fashion. If you read and re-read and study the Points of View column in Nature Methods, as well as most other data visualization guides, you'll see some patterns what visual properties of symbols are most easily connected to data.</p> <p>For quantitative data:</p> <ol> <li>Length and width are the easiest to map;</li> <li>Area is the next easiest scale on which to perceive scale;</li> <li>Transparency comes next,</li> <li>Colour is the last.</li> </ol> <p>In visualizing qualitative data, however, colour is an excellent first choice to begin with, provided you don't have too many categories to visualize (12 is a sane upper limit).</p> <p>In a graph visualization, the most obvious visual properties that we can control are:</p> <ol> <li>The size (area) of nodes,</li> <li>Their colour,</li> <li>And their transparency.</li> </ol>"},{"location":"theory/#draw-edges","title":"Draw edges","text":"<p>Once the nodes are drawn in, we next concern ourselves with how to draw edges. In most graph visualizations, edges are represented using using lines between the nodes. As such, we don't have to worry about the layout of edges; we only have to concern ourselves with the data-driven styling of the edges. The same principles apply above.</p> <p>How the lines are drawn may vary from plot type to plot type. For example, in a Hive plot, we may want to use Bezier curves to draw the lines, but in an Arc plot, we may want to use circular arcs instead. Meanwhile, in a Matrix plot, we might choose to use another shape to draw the edge rather than draw in a line. Either way, once we know the placement of the nodes, then we know how to draw in the relation between the two.</p>"},{"location":"theory/#add-in-annotations","title":"Add in annotations","text":"<p>Once the node layout, node styling, and edge styling are complete, we can add in annotations. For example, if there are groupings of nodes present, we can annotate the groups on the appropriate location. If there are colour mappings to quantitative values, then we might want to annotate the color bar on top.</p>"},{"location":"theory/#add-in-highlights","title":"Add in highlights","text":"<p>The final piece is to selectively add in highlights onto the plot. For example, we might wish to highlight a particular edge, or a particular group of edges. Or we might be interested in a particular node, and all of the edges that connect that node to other nodes. We might be concerned with in-edges only, or out-edges only, if we are dealing with a directed graph.</p>"},{"location":"theory/#composability","title":"Composability","text":"<p><code>nxviz</code> is designed with composability in mind. A pre-requisite of composability is that we are thinking clearly about what are independently-varying things that we can add up together. Shape and colour, for example, don't interfere with one another, and might be considered independent. Annotations can technically exist independent of node and edge drawing (though it might not be particularly meaningful); there's no deep-seated technical reason why we have to couple them together. Size and shape, by contrast, may get conflated with one another; for example, a square of side 4 units is going to be perceptually smaller than a circle of radius 4 units. The <code>nxviz</code> API is designed such that we can bring layout, styling, annotations and highlights in a composable fashion.</p>"},{"location":"theory/#panels","title":"Panels","text":"<p>Once we know how to build a single graph visualization, we can extend the visualization through the principle of small multiples to highlight interesting patterns in the graph data that might be obscured looking at it in its totality.</p> <p>What are the ways in which we might want to slice our data? Because we are building discrete subplots using data, the data we are mapping to each subplot ideally should be categorical in nature. Here's a few examples where we might want to do this.</p> <p>(1) Hive plots</p> <p>Hive plots are designed to show two or three groups of nodes and their connections. They aren't designed to do more than three groups because of geometric constraints. That said, we can work around this constraint by extracting triplet subgroups of nodes, thus building a hive panel.</p> <p>(2) Focusing on edge categories</p> <p>We might wish to highlight different categories of edges if the edges have categorical metadata available. In each category, we select only a particular subset of edges to plot, while preserving the node set. In this way, we can get an arbitrary graph visualization panel by simply filtering different edges to visualize.</p> <p>(3) Focusing on node categories</p> <p>This works similarly to edge categories, except now, we filter the graph for certain categories of nodes. Here, because the node set changes, the edge set will also change.</p>"},{"location":"theory/#nxviz-graph-filtering-api","title":"<code>nxviz</code> graph filtering API","text":"<p>To support building panels, the <code>nxviz</code> graph filtering API (located in the <code>nxviz.filter</code> submodule) provides a few basic ways of filtering a graph.</p> <ol> <li>Filtering edges by a categorical attribute.</li> <li>Filtering nodes by a categorical attribute.</li> <li>Filtering edges (all, in-edges, or out-edges) attached to a particular category of nodes.</li> </ol> <p>Because the graph filtering step is usually the piece that is the most hasslesome to write, these are provided in the library.</p>"},{"location":"api/facet-api/","title":"Faceting API","text":"<pre><code>%config InlineBackend.figure_format = 'retina'\n%load_ext autoreload\n%autoreload 2\n</code></pre> <pre><code>from random import choice\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\n\nimport nxviz as nv\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> <pre><code>categories = \"abcdefghijk\"\nnode_categories = \"12345\"\n\nG = nx.erdos_renyi_graph(n=70, p=0.1)\nfor u, v in G.edges():\n    G.edges[u, v][\"group\"] = choice(categories)\n    G.edges[u, v][\"edge_val\"] = np.random.exponential()\n\nfor n in G.nodes():\n    G.nodes[n][\"category\"] = choice(node_categories)\n    G.nodes[n][\"value\"] = np.random.normal()\n</code></pre> <pre><code>nv.circos(\n    G,\n    group_by=\"category\",\n    node_color_by=\"category\",\n    edge_color_by=\"edge_val\",\n    edge_enc_kwargs={\"alpha_scale\": 5},\n)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <p>This isn't particularly useful. The edges are over-populated on the visualization. If there were structure in the graph that were interesting, we'd find it hard to elucidate. Here, we can rely on the principle of small multiples to design a more effective visualizations.</p> <pre><code>from nxviz import annotate, facet\n\n# from nxviz import hive_panel, arc_panel, circos_panel\nfrom nxviz.utils import edge_table, node_table\n</code></pre> <pre><code>facet.arc_panel(\n    G,\n    edge_group_by=\"group\",\n    node_group_by=\"category\",\n    node_color_by=\"category\",\n    edge_color_by=\"edge_val\",\n)\n</code></pre> <pre><code>facet.circos_panel(\n    G,\n    edge_group_by=\"group\",\n    node_group_by=\"category\",\n    node_color_by=\"category\",\n    edge_color_by=\"edge_val\",\n)\n</code></pre> <pre><code>facet.matrix_panel(\n    G,\n    edge_group_by=\"group\",\n    node_group_by=\"category\",\n    node_color_by=\"category\",\n    edge_color_by=\"edge_val\",\n)\n</code></pre> <pre><code>facet.hive_panel(G, node_group_by=\"category\", node_color_by=\"category\")\n</code></pre> <pre><code>import inspect\n\nfrom nxviz.facet import n_rows_cols, node_group_edges\n\nprint(inspect.getsource(node_group_edges))\n</code></pre> <pre>\n<code>def node_group_edges(G: nx.Graph, group_by: Hashable):\n    \"\"\"Return a subgraph containing edges connected to a particular category of nodes.\"\"\"\n    nt = utils.node_table(G)\n    groups = sorted(nt[group_by].unique())\n\n    for group in groups:\n        G_sub = G.copy()\n        G_sub.remove_edges_from(G_sub.edges())\n\n        wanted_nodes = (n for n in G.nodes() if G.nodes[n][group_by] == group)\n        for node in wanted_nodes:\n            for u, v, d in G.edges(node, data=True):\n                G_sub.add_edge(u, v, **d)\n        yield G_sub, group\n\n</code>\n</pre> <pre><code>node_group_by = \"category\"\n\ngraphs, groups = zip(*node_group_edges(G, node_group_by))\nnrows, ncols = n_rows_cols(groups)\nfig, axes = plt.subplots(figsize=(8, 8), nrows=3, ncols=3)\naxes = list(axes.flatten())\n\nfor ax, G_sub, group in zip(axes, graphs, groups):\n    plt.sca(ax)\n    nv.circos(\n        G_sub, group_by=\"category\", sort_by=\"value\", node_color_by=\"category\"\n    )\n    annotate.circos_group(G_sub, group_by=\"category\")\n    ax.set_title(f\"node group = {group}\")\n\n\ni = axes.index(ax)\nfor ax in axes[i + 1 :]:\n    fig.delaxes(ax)\n\nplt.tight_layout()\n</code></pre> <pre><code>import inspect\n\nprint(inspect.getsource(facet.edge_group))\n</code></pre> <pre>\n<code>def edge_group(G: nx.Graph, group_by: Hashable):\n    \"\"\"Yield graphs containing only certain categories of edges.\"\"\"\n    et = utils.edge_table(G)\n    groups = sorted(et[group_by].unique())\n    for group in groups:\n        G_sub = G.copy()\n        G_sub.remove_edges_from(G_sub.edges())\n        for u, v, d in G.edges(data=True):\n            if d[group_by] == group:\n                G_sub.add_edge(u, v, **d)\n        yield G_sub, group\n\n</code>\n</pre> <p>The pattern is essentially to identify the exact groups that exist, iterate over these groups, and yield a graph that contains any one of the aforementioned three subsets alongside the group. That function pattern makes faceting consistent.</p>"},{"location":"api/facet-api/#panels-and-faceting","title":"Panels and Faceting","text":"<p>In this notebook, we will introduce how to make graph visualization panels!</p>"},{"location":"api/facet-api/#example-graph","title":"Example graph","text":"<p>Here's an example graph. It has both quantiative and qualitative data encoded on the nodes and edges.</p>"},{"location":"api/facet-api/#non-paneld-version","title":"Non-panel'd version","text":"<p>Let's see what happens if we just try to plot all nodes and all edges together.</p>"},{"location":"api/facet-api/#nxviz-faceting-api","title":"<code>nxviz</code> faceting API","text":"<p>Graph visualization panels are the solution here. We use categorical metadata on nodes or edges to facet our visualizations. (Faceting refers to creating subplots that contain a subset of the full dataset, so that one can optimize for visual clarity.)</p> <p>Because nodes are more easily arranged than edges, we can facet our graph out by edge categories into panels. As such, one subcategory of graph visualization panels is defined by a faceting of our graph by edge categories. Here are some examples.</p>"},{"location":"api/facet-api/#arc-panel","title":"Arc Panel","text":""},{"location":"api/facet-api/#circos-panel","title":"Circos Panel","text":""},{"location":"api/facet-api/#matrix-panel","title":"Matrix Panel","text":""},{"location":"api/facet-api/#hive-panel","title":"Hive Panel","text":"<p>Hive panels are a special type of panel. Because hive plots alone can plot either 2 or 3 categories of nodes, it can't handle situations where there are more than 3 categories of nodes. Here is where a panel of hive plots comes in: each plot in the panel handles 3 of the categories that are present. As such, you will have ${K}\\choose{3}$ plots to plot. For this reason, we don't recommend having more than 6 categories, otherwise you'll end up with a lot of plots to look at.</p>"},{"location":"api/facet-api/#custom-panels","title":"Custom panels","text":"<p>While there are plot-specific faceting APIs, you can use the building blocks in there to compose your own.</p> <p>In this example,  we'll show you how to create a facet where we show only edges that are associated with a particular group of nodes. For this, the key function to use is <code>node_group_edges</code>, which yields graphs that contains edges attached to a particular group, as well as the group itself.</p>"},{"location":"api/facet-api/#development-pattern","title":"Development pattern","text":"<p>The core of faceting in nxviz is to return an iterator of graphs that contain either</p> <ol> <li>a subset of nodes,</li> <li>a subset of edges,</li> <li>or a subset of nodes and edges.</li> </ol> <p>Using one of the faceting functions as an example to illustrate:</p>"},{"location":"api/high-level-api/","title":"High level API","text":"<pre><code>%config InlineBackend.figure_format = 'retina'\n%load_ext autoreload\n%autoreload 2\n</code></pre> <pre><code>from random import choice\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\n\nimport nxviz as nv\nfrom nxviz import annotate, highlights\nfrom nxviz.plots import despine, rescale, respine\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> <pre><code>G = nx.erdos_renyi_graph(n=71, p=0.1)\nfor n, d in G.nodes(data=True):\n    G.nodes[n][\"group\"] = choice([\"a\", \"b\", \"c\"])\n    G.nodes[n][\"value\"] = np.random.exponential()\n\nnp.random.seed(44)\nfor u, v, d in G.edges(data=True):\n    G.edges[u, v][\"edge_value\"] = np.random.exponential()\n\nfrom random import choice\n\nu, v = choice(list(G.edges()))\n</code></pre> <pre><code>from nxviz.utils import edge_table, node_table\n\nnode_table(G)\n</code></pre> group value 0 c 0.213805 1 c 1.784391 2 a 0.073540 3 c 0.403458 4 a 0.458212 ... ... ... 66 a 0.770954 67 a 1.606752 68 b 0.074074 69 a 0.719427 70 a 0.679490 <p>71 rows \u00d7 2 columns</p> <pre><code>edge_table(G)\n</code></pre> edge_value source target 0 1.800854 0 10 1 1.800854 10 0 2 0.110704 0 14 3 0.110704 14 0 4 1.365083 0 21 ... ... ... ... 501 0.918417 67 66 502 0.485085 67 68 503 0.485085 68 67 504 0.900958 69 70 505 0.900958 70 69 <p>506 rows \u00d7 3 columns</p> <pre><code>ax = nv.hive(\n    G,\n    group_by=\"group\",\n    sort_by=\"value\",\n    node_color_by=\"value\",\n    edge_alpha_by=\"edge_value\",\n)\nannotate.hive_group(G, group_by=\"group\", offset=np.pi / 12)\n</code></pre> <p>Here's an alternative visualization where we group and colour the nodes by their <code>group</code> attribute, ignoring the <code>value</code> attribute on the nodes and the <code>edge_value</code> attribute on the edges.</p> <pre><code>ax = nv.hive(G, group_by=\"group\", node_color_by=\"group\")\nannotate.hive_group(G, group_by=\"group\")\nhighlights.hive_node(G, u, group_by=\"group\")\nhighlights.hive_node(G, v, group_by=\"group\")\nhighlights.hive_edge(G, u, v, group_by=\"group\")\n</code></pre> <p>The same consistent API applies to the other plot types.</p> <pre><code>ax = nv.arc(\n    G, group_by=\"group\", node_color_by=\"group\", edge_alpha_by=\"edge_value\"\n)\nannotate.arc_group(G, group_by=\"group\", ha=\"center\", rotation=0)\nhighlights.arc_node(G, u, group_by=\"group\")\nhighlights.arc_node(G, v, group_by=\"group\")\nhighlights.arc_edge(G, source=u, target=v, group_by=\"group\")\n</code></pre> <pre><code>ax = nv.circos(\n    G, group_by=\"group\", node_color_by=\"group\", edge_alpha_by=\"edge_value\"\n)\nannotate.circos_group(G, group_by=\"group\")\n\nhighlights.circos_edge(G, u, v, group_by=\"group\")\nhighlights.circos_node(G, u, group_by=\"group\")\nhighlights.circos_node(G, v, group_by=\"group\", color=\"blue\")\n</code></pre> <pre><code>fig, ax = plt.subplots(figsize=(7, 7))\nax = nv.matrix(\n    G,\n    group_by=\"group\",\n    sort_by=\"value\",\n    node_color_by=\"group\",\n    edge_alpha_by=\"edge_value\",\n)\nannotate.matrix_group(G, group_by=\"group\")\nannotate.matrix_block(G, group_by=\"group\", color_by=\"group\", alpha=0.1)\nhighlights.matrix_node(G, u, group_by=\"group\", sort_by=\"value\")\nhighlights.matrix_node(G, v, group_by=\"group\", sort_by=\"value\", color=\"blue\")\nhighlights.matrix_row(G, u, group_by=\"group\", sort_by=\"value\")\nhighlights.matrix_row(G, v, group_by=\"group\", sort_by=\"value\", axis=\"y\", color=\"blue\")\n\nhighlights.matrix_edge(G, u, v, group_by=\"group\", sort_by=\"value\")\n</code></pre> <pre><code>\n</code></pre>"},{"location":"api/high-level-api/#high-level-api","title":"High Level API","text":"<p>In this notebook, we will walk through the high level nxviz API.</p> <p>The intent here is to provide a convenient (albeit restrictive) way to build graph visualizations for exploratory analysis purposes. Our goal is to help you declaratively visualize a network using one of the rational visualizations provided. The design is intentionally quite restrictive; customizations are limited to what you can compose together.</p> <p>You should treat these the way you would use the plotting package <code>seaborn</code>: to get you a quick overview of your data without being bogged down by the details of how things are placed on the screen. If you want finer-grained control, then you may wish to drop down to the mid-level or low-level API instead.</p>"},{"location":"api/high-level-api/#how-to-read-this-notebook","title":"How to read this notebook","text":"<p>Treat this notebook as a gallery of examples. As with all declarative APIs, it's important to know the structure of the graph. We're showing you the exact source code for graph construction, and the graph's corresponding node and edge tables, to make things easier to read.</p>"},{"location":"api/high-level-api/#example-graph","title":"Example Graph","text":"<p>We're going to use an example graph, the erdos-renyi graph, to illustrate.</p>"},{"location":"api/high-level-api/#source-code","title":"Source code","text":"<p>Here's the source code for graph generation.</p>"},{"location":"api/high-level-api/#node-table","title":"Node table","text":""},{"location":"api/high-level-api/#hive-plot","title":"Hive Plot","text":"<p>Here's a Hive Plot view of the graph.</p> <p>The Hive plot is appropriate here, because we have one categorical variables with three values by which we can group our nodes.</p> <p>Here's one example where we group the nodes by their <code>group</code> attribute, sort and colour them by their <code>value</code> attribute, and set the transparency of an aged based on the edge's <code>edge_value</code> attribute. We also annotate the grouping on the hive plot.</p>"},{"location":"api/high-level-api/#arc-plot","title":"Arc Plot","text":""},{"location":"api/high-level-api/#circos-plot","title":"Circos Plot","text":""},{"location":"api/high-level-api/#matrix-plot","title":"Matrix Plot","text":""},{"location":"api/low-level-api/","title":"Low-level API","text":"<pre><code>%config InlineBackend.figure_format = 'retina'\n%load_ext autoreload\n%autoreload 2\n</code></pre> <pre><code>from random import choice\n\nimport networkx as nx\nimport numpy as np\n\nG = nx.erdos_renyi_graph(n=71, p=0.1)\nfor n, d in G.nodes(data=True):\n    G.nodes[n][\"group\"] = choice([\"a\", \"b\", \"c\"])\n    G.nodes[n][\"value\"] = np.random.exponential()\n\nnp.random.seed(44)\nfor u, v, d in G.edges(data=True):\n    G.edges[u, v][\"edge_value\"] = np.random.exponential()\n</code></pre> <pre><code>from nxviz import utils\n\nnt = utils.node_table(G)\nnt.head()\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> group value 0 b 0.041772 1 b 0.301609 2 c 1.425492 3 c 1.476678 4 b 0.117126 <p>The node table is indexed by node ID, and all of the metadata attributes are stored as columns.</p> <pre><code>et = utils.edge_table(G)\net.head()\n</code></pre> edge_value source target 0 1.800854 0 17 1 1.800854 17 0 2 0.110704 0 19 3 0.110704 19 0 4 1.365083 0 28 <p>For the edge table, the \"source\" and \"target\" columns are the node IDs in the node table. Every other column is a metadata field. The index carries no semantic meaning here.</p> <pre><code>from nxviz import layouts\n\npos = layouts.circos(nt, group_by=\"group\")\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\n\nfrom nxviz import encodings as aes\n\n\ndef group_colormap(data: pd.Series):\n    cmap = {\"a\": \"black\", \"b\": \"blue\", \"c\": \"red\"}\n    return data.apply(lambda x: cmap.get(x))\n\n\ndef value_colormap(data: pd.Series):\n    \"\"\"Value colormap.\"\"\"\n    norm = plt.cm.Normalize(vmin=data.min(), vmax=data.max())\n    cmap = plt.cm.get_cmap(\"viridis\")\n    return data.apply(lambda x: cmap(norm(x)))\n\n\ndef node_size(data: pd.Series):\n    return data.apply(np.sqrt)\n</code></pre> <p>We can now combine everything together, into something that basically reconstructs <code>nodes.draw</code>.</p> <pre><code>import inspect\n\nfrom nxviz import nodes, plots\n\nprint(inspect.getsource(nodes.draw))\n</code></pre> <pre>\n<code>def draw(\n    G: nx.Graph,\n    layout_func: Callable,\n    group_by: Hashable,\n    sort_by: Hashable,\n    color_by: Hashable = None,\n    alpha_by: Hashable = None,\n    size_by: Hashable = None,\n    layout_kwargs: Dict = {},\n    encodings_kwargs: Dict = {},\n    rescale_func=rescale,\n    ax=None,\n    palette: Optional[Union[Dict, List]] = None,\n):\n    \"\"\"Draw nodes to matplotlib axes.\n\n    ## Parameters\n\n    - `G`: The graph to plot.\n    - `layout_func`: One of the node layout functions from `nxviz.layout`.\n    - `group_by`: Categorical attribute key to group nodes by.\n    - `sort_by`: Quantitative or ordinal attribute key to sort nodes.\n    - `color_by`: Node attribute key to color nodes by.\n    - `alpha_by`: Quantitative node attribute key to set transparency.\n    - `size_by`: Quantitative node attribute key to set node size.\n    - `layout_kwargs`: Keyword arguments to pass\n        to the appropriate layout function.\n    - `encodings_kwargs`: A dictionary of kwargs\n        to determine the visual properties of the node.\n    - `palette`: Optional custom palette of colours for plotting categorical groupings\n        in a list/dictionary. Colours must be values `matplotlib.colors.ListedColormap`\n        can interpret. If a dictionary is provided, key and record corresponds to\n        category and colour respectively.\n\n    Special keyword arguments for `encodings_kwargs` include:\n\n    - `size_scale`: A scaling factor for all node radii.\n        Equivalent to multiplying all node radii by this number.\n    - `alpha_scale`: A scaling factor for all nodes' transparencies.\n        Equivalent to multiplying all alphas by this number.\n        The default transparency is 1.0.\n        If you need to make the nodes transparent,\n        use a value smaller than one.\n    - `alpha_bounds`: The bounds for transparency.\n        Should be a tuple of `(lower, upper)` numbers.\n        This keyword argument lets us manually set the bounds\n        that we wish to have for 0 opacity (i.e. transparent)\n        to 1.0 opacity (i.e. opaque.)\n\n    Everything else passed in here will be passed\n    to the matplotlib Patch constructor;\n    see `nxviz.lines` for more information.\n    \"\"\"\n    if ax is None:\n        ax = plt.gca()\n    nt = node_table(G)\n    pos = layout_func(nt, group_by, sort_by, **layout_kwargs)\n    node_color = node_colors(nt, color_by, palette)\n\n    encodings_kwargs = deepcopy(encodings_kwargs)\n    alpha_bounds = encodings_kwargs.pop(\"alpha_bounds\", None)\n    alpha = transparency(nt, alpha_by, alpha_bounds) * encodings_kwargs.pop(\n        \"alpha_scale\", 1\n    )\n    size = node_size(nt, size_by) * encodings_kwargs.pop(\"size_scale\", 1)\n    patches = node_glyphs(nt, pos, node_color, alpha, size, **encodings_kwargs)\n    for patch in patches:\n        ax.add_patch(patch)\n\n    rescale_func(G)\n    return pos\n\n</code>\n</pre> <pre><code>ax = plt.gca()\n\n# Customize node styling\nnt = utils.node_table(G)\npos = layouts.circos(nt, group_by=\"group\", sort_by=\"value\")\nnode_color = group_colormap(nt[\"group\"])\nalpha = nodes.transparency(nt, alpha_by=None)\nsize = nodes.node_size(nt, \"value\")\npatches = nodes.node_glyphs(\n    nt, pos, node_color=node_color, alpha=alpha, size=size\n)\nfor patch in patches:\n    ax.add_patch(patch)\nplots.rescale(G)\nplots.aspect_equal()\n</code></pre> <p>Voila! We now have a sonic hedgehog-style node layout! Pretty cool, isn't it?</p> <p>Once the node layout is complete, customizing the edge styling is a matter of concerning ourselves with:</p> <ol> <li>Line width</li> <li>Transparency</li> <li>Color</li> </ol> <p>We could customize more, but these three are the most commonly-used for mapping data to style. As with node layouts, we basically have to re-create <code>nxviz.edges.draw</code> with customized data-to-style mapping functions.</p> <pre><code>from nxviz import edges\n\nprint(inspect.getsource(edges.draw))\n</code></pre> <pre>\n<code>def draw(\n    G: nx.Graph,\n    pos: Dict[Hashable, np.ndarray],\n    lines_func: Callable,\n    color_by: Hashable = None,\n    node_color_by: Hashable = None,\n    lw_by: Hashable = None,\n    alpha_by: Hashable = None,\n    ax=None,\n    encodings_kwargs: Dict = {},\n    palette: Optional[Union[Dict, List]] = None,\n    **linefunc_kwargs,\n):\n    \"\"\"Draw edges to matplotlib axes.\n\n    ## Parameters\n\n    - `G`: A NetworkX graph.\n    - `pos`: A dictionary mapping for x,y coordinates of a node.\n    - `lines_func`: One of the line drawing functions from `nxviz.lines`\n    - `color_by`: Categorical or quantitative edge attribute key to color edges by.\n        There are two special value for this parameter\n        when using directed graphs:\n        \"source_node_color\" and \"target_node_color\".\n        If these values are set, then `node_color_by` also needs to be set.\n    - `node_color_by`: Node metadata attribute key\n        that has been used to color nodes.\n    - `node_color_by`: Node metadata attribute key that has been used to\n        color nodes.\n    - `lw_by`: Quantitative edge attribute key to determine line width.\n    - `alpha_by`: Quantitative edge attribute key to determine transparency.\n    - `ax`: Matplotlib axes object to plot onto.\n    - `encodings_kwargs`: A dictionary of kwargs\n        to determine the visual properties of the edge.\n    - `palette`: Optional custom palette of colours for plotting categorical groupings\n        in a list/dictionary. Colours must be values `matplotlib.colors.ListedColormap`\n        can interpret. If a dictionary is provided, key and record corresponds to\n        category and colour respectively.\n    - `linefunc_kwargs`: All other keyword arguments passed in\n        will be passed onto the appropriate linefunc.\n\n    Special keyword arguments for `encodings_kwargs` include:\n\n    - `lw_scale`: A scaling factor for all edges' line widths.\n        Equivalent to multiplying all line widths by this number.\n    - `alpha_scale`: A scaling factor for all edges' line transparencies.\n        Equivalent to multiplying all alphas by this number.\n        The default transparency is 0.1,\n        so an alpha_scale of any number greater than or equal to 10\n        will result in 100% opaque lines.\n    - `alpha_bounds`: The bounds for transparency.\n        Should be a tuple of `(lower, upper)` numbers.\n        This keyword argument lets us manually set the bounds\n        that we wish to have for 0 opacity (i.e. transparent)\n        to 1.0 opacity (i.e. opaque.)\n\n    Everything else passed in here will be passed\n    to the matplotlib Patch constructor;\n    see `nxviz.lines` for more information.\n    \"\"\"\n    nt = node_table(G)\n    et = edge_table(G)\n    if ax is None:\n        ax = plt.gca()\n    validate_color_by(G, color_by, node_color_by)\n    edge_color = edge_colors(et, nt, color_by, node_color_by, palette)\n    encodings_kwargs = deepcopy(encodings_kwargs)\n    lw = line_width(et, lw_by) * encodings_kwargs.pop(\"lw_scale\", 1.0)\n\n    alpha_bounds = encodings_kwargs.pop(\"alpha_bounds\", None)\n    alpha = transparency(et, alpha_by, alpha_bounds) * encodings_kwargs.pop(\n        \"alpha_scale\", 1.0\n    )\n\n    aes_kw = {\"facecolor\": \"none\"}\n    aes_kw.update(encodings_kwargs)\n    patches = lines_func(\n        et,\n        pos,\n        edge_color=edge_color,\n        alpha=alpha,\n        lw=lw,\n        aes_kw=aes_kw,\n        **linefunc_kwargs,\n    )\n    for patch in patches:\n        ax.add_patch(patch)\n\n</code>\n</pre> <pre><code>from nxviz import lines\n\n# Customize node styling\nax = plt.gca()\n\nnt = utils.node_table(G)\npos = layouts.circos(nt, group_by=\"group\", sort_by=\"value\")\nnode_color = group_colormap(nt[\"group\"])\nalpha = nodes.transparency(nt, alpha_by=None)\nsize = nodes.node_size(nt, \"value\")\npatches = nodes.node_glyphs(\n    nt, pos, node_color=node_color, alpha=alpha, size=size\n)\nfor patch in patches:\n    ax.add_patch(patch)\n\n# Customize edge styling\net = utils.edge_table(G)\nedge_color = edges.edge_colors(et, nt=None, color_by=None, node_color_by=None)\nlw = np.sqrt(et[\"edge_value\"])\nalpha = edges.transparency(et, alpha_by=None)\npatches = lines.circos(\n    et, pos, edge_color=edge_color, alpha=alpha, lw=lw, aes_kw={\"fc\": \"none\"}\n)\nfor patch in patches:\n    ax.add_patch(patch)\n\nplots.rescale(G)\nplots.aspect_equal()\nplots.despine()\n</code></pre> <p>Looking at the plot, we might find that expressing the edges' <code>edge_value</code> as line width might not be that effective. Instead, we might want to express it using alpha.</p> <pre><code>from nxviz import lines\n\n# Customize node styling\nax = plt.gca()\n\nnt = utils.node_table(G)\npos = layouts.circos(nt, group_by=\"group\", sort_by=\"value\")\nnode_color = group_colormap(nt[\"group\"])\nalpha = nodes.transparency(nt, alpha_by=None)\nsize = nodes.node_size(nt, \"value\")\npatches = nodes.node_glyphs(\n    nt, pos, node_color=node_color, alpha=alpha, size=size\n)\nfor patch in patches:\n    ax.add_patch(patch)\n\n# Customize edge styling\net = utils.edge_table(G)\nedge_color = edges.edge_colors(et, nt=None, color_by=None, node_color_by=None)\nlw = edges.line_width(et, lw_by=None)\nalpha = edges.transparency(et, alpha_by=\"edge_value\")\npatches = lines.circos(\n    et, pos, edge_color=edge_color, alpha=alpha, lw=lw, aes_kw={\"fc\": \"none\"}\n)\nfor patch in patches:\n    ax.add_patch(patch)\n\nplots.rescale(G)\nplots.aspect_equal()\nplots.despine()\n</code></pre> <p>Looking at this plot, it's a lot easier for us to see the important edges (as visualized by the alpha value).</p>"},{"location":"api/low-level-api/#low-level-api","title":"Low-level API","text":"<p>The <code>nxviz</code> low level API is one that provides the most flexibility for constructing rational graph visualizations.</p> <p>As always, with rational graph visualizations, there is a process involved that helps us compose together beautiful visualizations. We first concern ourselves with the node placement using the layout functions. Then, we concern ourselves with data-driven visual styling of the nodes. After that, we figure out how to draw edges (whether as lines or bezier curves) and style them according to data.</p>"},{"location":"api/low-level-api/#example","title":"Example","text":"<p>As an example, let's see how we make can make customizations to the Circos plot by using the low-level API.</p> <p>For some of these things, we might be able to accomplish them using the higher level API, but we will intentionally show the low-level way of handling these customizations so that you can have a feel for how you can implement low-level customizations.</p>"},{"location":"api/low-level-api/#node-and-edge-table","title":"Node and Edge Table","text":"<p>The node and edge tables are the low-level data structures that are used in creating network visualizations. These are pandas DataFrames.</p>"},{"location":"api/low-level-api/#circos-layout","title":"Circos layout","text":"<p>Following the principles of rational graph visualization, we start by declaring the layout that we want. Since in our example we'll be using the Circos plot layout, let's start by obtaining the (x, y) coordinate positions of each node that we want to plot.</p> <p>The <code>nxviz.layouts</code> module contains the circos plot layout function that we'll want. Underneath the hood, it uses pandas' group-by and sorting functionality to get nodes into the correct order that we want. If you wish to group and sort in a customized fashion, then you'll have to implement the functionality yourself.</p>"},{"location":"api/low-level-api/#node-styling","title":"Node styling","text":"<p>Next, we concern ourselves with the styling of the nodes. Here, the <code>nxviz.encodings</code> submodule becomes useful for us.</p> <p>When drawing nodes, their color, transparency, and size can be most naturally mapped to data.</p> <ul> <li>Transparency requires that a quantitative value be mappable to the interval (0, 1).</li> <li>Size requires that a quantitative value be mappable to the positive floats (0, +inf).</li> <li>Color is the trickiest of them all:<ul> <li>A categorical variable should be mapped to a categorical colormap.</li> <li>A continuous variable should be mapped to a continuous colormap.</li> </ul> </li> </ul> <p>The choice of colormap is always going to be dependent on the user. If you're looking for a guide on how to choose colormaps, the Points of View guide to colors is a very good resource to start with.</p> <p>How do we handle styling of nodes? The primary way of doing so is to have a Python function that maps from the node table's column of values (passed in as a pandas Series) to any color specification that matplotlib can handle:</p> <ul> <li>Strings: \"black\", \"yellow\", \"blue\", etc.</li> <li>RGB(A): <code>(0.1, 0.8, 0.3, 0.5)</code></li> <li>Hexadecimal: <code>#FFFFFF</code>, <code>#000000</code>, <code>#A7C91F</code></li> </ul> <p>Here's two examples, one using a highly custom mapping, and the other using matplotlib's color maps.</p>"},{"location":"api/low-level-api/#adding-in-edges","title":"Adding in edges","text":""},{"location":"api/low-level-api/#conclusion","title":"Conclusion","text":"<p>Throughout this notebook, we dropped down from the mid-level API to the low-level API, where we get to customize node and edge styling to our heart's content. The patterns are easy to follow. For nodes, we customize the size, color and transparency. For edges we customize the line width, color, and transparency. We can then compose them together into the plots we see above.</p>"},{"location":"api/mid-level-api/","title":"Mid-level API","text":"<pre><code>%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</code></pre> <pre><code>from random import choice\n\nimport networkx as nx\n</code></pre> <pre><code>import io\nimport urllib.request as urllib\nimport zipfile\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nurl = \"http://www-personal.umich.edu/~mejn/netdata/football.zip\"\n\nsock = urllib.urlopen(url)  # open URL\ns = io.BytesIO(sock.read())  # read into BytesIO \"file\"\nsock.close()\n\nzf = zipfile.ZipFile(s)  # zipfile object\ntxt = zf.read(\"football.txt\").decode()  # read info file\ngml = zf.read(\"football.gml\").decode()  # read gml data\n# throw away bogus first line with # from mejn files\ngml = gml.split(\"\\n\")[1:]\nG = nx.parse_gml(gml)  # parse gml data\nprint(txt)\n\nmapping = dict(\n    {\n        0: \"Atlantic Coast\",\n        1: \"Big East\",\n        2: \"Big Ten\",\n        3: \"Big Twelve\",\n        4: \"Conference USA\",\n        5: \"Independents\",\n        6: \"Mid-American\",\n        7: \"Mountain West\",\n        8: \"Pacific Ten\",\n        9: \"Southeastern\",\n        10: \"Sun Belt\",\n        11: \"Western Athletic\",\n    }\n)\nfor node, data in G.nodes(data=True):\n    G.nodes[node][\"conference\"] = mapping[data[\"value\"]]\n</code></pre> <pre>\n<code>The file football.gml contains the network of American football games\nbetween Division IA colleges during regular season Fall 2000, as compiled\nby M. Girvan and M. Newman.  The nodes have values that indicate to which\nconferences they belong.  The values are as follows:\n\n  0 = Atlantic Coast\n  1 = Big East\n  2 = Big Ten\n  3 = Big Twelve\n  4 = Conference USA\n  5 = Independents\n  6 = Mid-American\n  7 = Mountain West\n  8 = Pacific Ten\n  9 = Southeastern\n 10 = Sun Belt\n 11 = Western Athletic\n\nIf you make use of these data, please cite M. Girvan and M. E. J. Newman,\nCommunity structure in social and biological networks,\nProc. Natl. Acad. Sci. USA 99, 7821-7826 (2002).\n\nCorrection: Two edges were erroneously duplicated in this data set, and\nhave been removed (21 SEP 2014)\n\n</code>\n</pre> <pre><code>nx.draw(G)\n</code></pre> <p>That looks a bit like a hairball. How can we make it look nicer?</p> <pre><code>from nxviz import nodes\n\npos = nodes.circos(G)\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> <p>Right now, it doesn't look like much - a blue donut, basically. That is because there are a bunch of circles of radius 1 (the default radius) that are overlapping with one another. To make things a bit more informative, we should probably group the nodes by their conference.</p> <p>Here is where nxviz's API becomes apparent. We can refine the positioning of the nodes by specifying how to group them and sort them. This is accomplished by specifying the <code>group_by</code> and <code>sort_by</code> keyword arguments. Let's see the effect of specifying <code>group_by</code>:</p> <pre><code>pos = nodes.circos(G, group_by=\"conference\")\n</code></pre> <p>You might be wondering, why didn't that do anything? Actually, it did, but things are not yet visually apparent because we have only concerned ourselves with the positions of the nodes and not the visual properties of the nodes. The visual properties of the node that can be mapped to data are the color, the transparency, and the node size. By default, node colors are blue, transparency (the alpha parameter in matplotlib) is 1, and node size is 1. Let's see how we can declare that we want our nodes to be coloured by conference while also being ordered by conference.</p> <pre><code>pos = nodes.circos(G, group_by=\"conference\", color_by=\"conference\")\n</code></pre> <p>Things are starting to look promising! Though, if I were to comment on it, the plot is also still quite ugly. Let's start by applying a uniform scaling factor to all of the nodes to scale them to the size of the plot. (This is the <code>size_scale</code> encoding keyword argument that we'll be specifying below.)</p> <pre><code>pos = nodes.circos(G, group_by=\"conference\", color_by=\"conference\")\n</code></pre> <p>The nodes look a bit more appropriately sized! The Circos plot still looks a bit squishy though. There's some adjustments we need to do to the plot to make it look nice. We need to remove the spines and ticks to get rid of the boxiness effect. We also need to make the aspect ratio on the x- and y-axes equal.</p> <p><code>despine()</code> will accomplish the first.</p> <pre><code>from nxviz.plots import aspect_equal, despine\n\npos = nodes.circos(G, group_by=\"conference\", color_by=\"conference\")\ndespine()\n</code></pre> <p>Putting it together with <code>aspect_equal()</code> will get us to a good starting point.</p> <pre><code>pos = nodes.circos(G, group_by=\"conference\", color_by=\"conference\")\ndespine()\naspect_equal()\n</code></pre> <p>Voila! With the nodes rationally laid out, we have an awesome starting point for adding in the edges.</p> <p>Edge drawing requires that we have the positions of the nodes available. That we obtain from the <code>nodes.circos</code> (or other node drawing) function. We can then pass it to any of the edge drawing functions.</p> <p>When drawing edges, because we are drawing relations and not entities, we are no longer concerned with grouping and sorting. Instead, we are concerned with only the visual properties of the lines. The ones that are most easily mappable to data are:</p> <ol> <li>Line width</li> <li>Transparency</li> <li>Line color</li> </ol> <p>The <code>edges.circos</code> function is the most logical here, so we'll kick off with that one.</p> <pre><code>from nxviz import edges\n\npos = nodes.circos(G, group_by=\"conference\", color_by=\"conference\")\nedges.circos(G, pos)\n\ndespine()\naspect_equal()\n</code></pre> <p>An alternative to drawing circos edges is to draw lines directly for each edge.</p> <pre><code>pos = nodes.circos(G, group_by=\"conference\", color_by=\"conference\")\nedges.line(G, pos)\n\ndespine()\naspect_equal()\n</code></pre> <p>Regardless of which edge drawing method we choose, the chart might not be sufficiently ready for our purposes, though. After all, we have no idea what groups map to which color. If we annotate the circos group onto the plot, it becomes much clearer which colors map to which group.</p> <pre><code>from nxviz import annotate\n\npos = nodes.circos(G, group_by=\"conference\", color_by=\"conference\")\nedges.circos(G, pos)\nannotate.circos_group(G, group_by=\"conference\")\n\ndespine()\naspect_equal()\n</code></pre> <p>Now it is clear that there are quite a lot of within-conference edges, and only some cross-conference edges between teams.</p> <pre><code>pos = nodes.arc(G, group_by=\"conference\", color_by=\"conference\")\nedges.arc(G, pos)\nannotate.arc_group(G, group_by=\"conference\")\n\ndespine()\naspect_equal()\n</code></pre> <pre><code>from nxviz import edges, nodes\n\npos = nodes.parallel(G, group_by=\"conference\", color_by=\"conference\")\nedges.line(G, pos)\nannotate.parallel_group(G, group_by=\"conference\")\ndespine()\naspect_equal()\n</code></pre> <p>The parallel coordinates layout might not necessarily be the most informative for this graph dataset, but we still show it here just to give you a flavour for what is possible with it. It may be more suited to bipartite graphs, which explicitly do not allow for edges within a single group.</p> <pre><code>import numpy as np\n\nfrom nxviz import nodes\nfrom nxviz.utils import node_table\n\nconferences = [\"Atlantic Coast\", \"Independents\", \"Sun Belt\"]\nnt = node_table(G)\nwanted_nodes = nt.query(\"`conference` in @conferences\").index\n\nG_sub = G.subgraph(wanted_nodes)\n\nsize_scale = 0.5\n# radius = 2\npos = nodes.hive(G_sub, group_by=\"conference\", color_by=\"conference\")\npos_cloned = nodes.hive(\n    G_sub,\n    group_by=\"conference\",\n    color_by=\"conference\",\n    layout_kwargs=dict(rotation=np.pi / 6),\n)\nedges.hive(G_sub, pos, pos_cloned=pos_cloned)\nannotate.node_colormapping(G_sub, color_by=\"conference\")\ndespine()\naspect_equal()\n</code></pre> <p>And here, we see an interesting pattern show up that might not have been visible earlier on: The Atlantic Coast teams have a lot of in-group edges than between-group edges, while the independents appear to have lots more between-group edges than in-group edges.</p>"},{"location":"api/mid-level-api/#mid-level-api","title":"Mid-Level API","text":"<p>As a graph visualization package built on top of NetworkX, <code>nxviz</code>'s design is highly inspired by the grammar of graphics. In particular, we see network visualizations as being composed of two main components, which correspond to the two objects that comprise a graph:</p> <ol> <li>Nodes: their layout (position, grouping &amp; ordering), and visual styling (color, size, and transparency).</li> <li>Edges: their visual styling (color, width, and transparency).</li> </ol> <p>In addition to these, we may choose to add annotations and highlights onto the network visualization, such as node and/or edge labels, particular nodes and/or edges being highlighted, color bars or legends, and more.</p> <p>As such, the low-level functional API is designed around these ideas. In this notebook, we would like to highlight how the low-level API can be used to compose beautiful network visualizations, as long as one structures one's thinking around these principles.</p>"},{"location":"api/mid-level-api/#an-example-graph","title":"An example graph","text":"<p>To illustrate, we will use the Karate Club Graph from NetworkX's library.</p>"},{"location":"api/mid-level-api/#visualization-using-networkxs-built-in-facilities","title":"Visualization using NetworkX's built-in facilities","text":"<p>NetworkX does come with its own built-in visualization facilities. Let's see what visualizations we get.</p>"},{"location":"api/mid-level-api/#node-layout","title":"Node Layout","text":"<p>The first thing we should worry about is the node layout. This specifically refers to how nodes are positioned on the 2D plane. In a rational graph visualization, node placement should always take priority, as nodes represent entities with properties that we can grasp.</p> <p>The Circos plot layout lays out the nodes around the circumference of a circle. Hence, by stating up-front that we want a Circos layout, we take care of the first step of graph visualization, that is node placement.</p> <p>The <code>nodes</code> module provides a bunch of node drawing algorithms. They all take in the graph object <code>G</code> and return a position dictionary. That position dictionary is necessary for drawing edges, as we'll see in a moment.</p>"},{"location":"api/mid-level-api/#other-layouts","title":"Other layouts","text":""},{"location":"api/mid-level-api/#arc-layout","title":"Arc layout","text":""},{"location":"api/mid-level-api/#parallel-coordinates-layout","title":"Parallel coordinates layout","text":""},{"location":"api/mid-level-api/#hive-plot-layout","title":"Hive plot layout","text":"<p>The hive plot is a bit special, in that it is suitable for only plotting a maximum of 3 groups. If we isolate nodes from just the Atlantic Coast, Independents, and Sun Belt, then we have a suitable way of plotting hive plots.</p> <p>Grouping is crucial to the Hive plot; we........</p> <p>Notice here that we take advantage of the <code>node_table</code> version of a graph's nodes, which is essentially a listing of all of the nodes and their properties. The node table works well for unipartite graphs, but needs to be modified for bipartite graphs.</p>"},{"location":"api/mid-level-api/#conclusions","title":"Conclusions","text":"<p>This notebook's intent is to show you how the mid-level API of <code>nxviz</code> expresses a thought framework for drawing networks in a rational fashion. We start with a particular layout (positions) for the nodes, deciding on their grouping and ordering. We then declare their size, color, and transparency, based on data attributes that are present on there.</p> <p>Next, we declare the way to draw edges. Each layout has its own particular idiomatic edge drawing method, and usually the easiest way to handle this is to use the corresponding edges function.</p> <p>APIs that live at a higher level of abstraction usually imply more restrictions, as the intent here is usually to trade off customizable details for simplicity. The mid-level API allows us to gain finer-grained control over plots while remaining declarative. Changing the colormap, in particular, is out of scope for the mid-level API.</p> <p>The highest level of the <code>nxviz</code> API is object-based and opinionatedly pairs certain node layouts with certain edge drawing functions, not allowing for any customization there. The lowest-level API is where one interacts with the lines, layouts, positions directly, exposing more direct interaction with <code>matplotlib</code>.</p>"},{"location":"api/object-oriented-api/","title":"Object-oriented API","text":"<pre><code>%config InlineBackend.figure_format = 'retina'\n%load_ext autoreload\n%autoreload 2\n</code></pre> <pre><code>from random import choice\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\n\nimport nxviz as nv\nfrom nxviz import annotate\nfrom nxviz.plots import despine, rescale, respine\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> <pre><code>G = nx.erdos_renyi_graph(n=71, p=0.1)\nfor n, d in G.nodes(data=True):\n    G.nodes[n][\"group\"] = choice([\"a\", \"b\", \"c\"])\n    G.nodes[n][\"value\"] = np.random.exponential()\n\nnp.random.seed(44)\nfor u, v, d in G.edges(data=True):\n    G.edges[u, v][\"edge_value\"] = np.random.exponential()\n</code></pre> <pre><code>nv.HivePlot(G, node_grouping=\"group\", node_color=\"value\", node_order=\"value\", edge_alpha=\"edge_value\")\nfrom nxviz import annotate\n\nannotate.hive_group(G, group_by=\"group\", offset=np.pi / 12)\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/api.py:299: UserWarning: As of nxviz 0.7, the object-oriented API is being deprecated in favour of a functional API. Please consider switching your plotting code! The object-oriented API wrappers remains in place to help you transition over. A few changes between the old and new API exist; please consult the nxviz documentation for more information. When the 1.0 release of nxviz happens, the object-oriented API will be dropped entirely.\n  warnings.warn(\n</code>\n</pre> <pre><code>nv.CircosPlot(G, node_grouping=\"group\", node_color=\"value\", node_order=\"value\")\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/api.py:299: UserWarning: As of nxviz 0.7, the object-oriented API is being deprecated in favour of a functional API. Please consider switching your plotting code! The object-oriented API wrappers remains in place to help you transition over. A few changes between the old and new API exist; please consult the nxviz documentation for more information. When the 1.0 release of nxviz happens, the object-oriented API will be dropped entirely.\n  warnings.warn(\n</code>\n</pre> <pre>\n<code>&lt;nxviz.api.CircosPlot at 0x7ff70e66d010&gt;</code>\n</pre> <pre><code>nv.MatrixPlot(G, node_grouping=\"group\", node_color=\"value\", node_order=\"value\")\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/api.py:299: UserWarning: As of nxviz 0.7, the object-oriented API is being deprecated in favour of a functional API. Please consider switching your plotting code! The object-oriented API wrappers remains in place to help you transition over. A few changes between the old and new API exist; please consult the nxviz documentation for more information. When the 1.0 release of nxviz happens, the object-oriented API will be dropped entirely.\n  warnings.warn(\n</code>\n</pre> <pre>\n<code>&lt;nxviz.api.MatrixPlot at 0x7ff70e66d160&gt;</code>\n</pre> <pre><code>nv.ArcPlot(\n    G,\n    node_grouping=\"group\",\n    node_color=\"value\",\n    node_order=\"value\",\n    edge_color=\"edge_value\",\n)\nannotate.arc_group(G, group_by=\"group\", rotation=0)\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/api.py:299: UserWarning: As of nxviz 0.7, the object-oriented API is being deprecated in favour of a functional API. Please consider switching your plotting code! The object-oriented API wrappers remains in place to help you transition over. A few changes between the old and new API exist; please consult the nxviz documentation for more information. When the 1.0 release of nxviz happens, the object-oriented API will be dropped entirely.\n  warnings.warn(\n</code>\n</pre>"},{"location":"api/object-oriented-api/#object-oriented-api","title":"Object-Oriented API","text":"<p>For those who may prefer the object-oriented API of the past, we provide the following class definitions that map directly to the functions.</p>"},{"location":"api/object-oriented-api/#example-graph","title":"Example Graph","text":"<p>We're going to use an example graph, the erdos-renyi graph, to illustrate.</p>"},{"location":"api/object-oriented-api/#source-code","title":"Source code","text":""},{"location":"api/object-oriented-api/#api-examples","title":"API Examples","text":"<p>The API from pre-0.7 is mostly preserved as a way  to help users who learned the object-oriented API transition over. A key difference here is that instantiating the object  and then calling <code>.draw()</code> is no longer necessary. Additionally, annotation logic has been moved out of the class definitions  and are now available as part of the annotations submodule.</p> <p>Because the API is no longer being officially supported, these will be officially deprecated in version 1.0. A warning message will show up the first time you try to access any of the objects provided. PRs that try to add an object version of a plot will also be rejected.</p>"},{"location":"developers/architecture/","title":"Library Architecture","text":"<p><code>nxviz</code>'s architecture, or how the code is organized, follows the logical structure of prioritizing nodes' positioning over edges. As such, there are multiple API layers. We have documentation on how to use each of those API layers, so we won't go through them too closely here.</p>"},{"location":"developers/architecture/#high-level","title":"High level","text":"<p>At the high level, we provide the following plots in the <code>nxviz</code> main namespace:</p> <ul> <li>Graph visualizations with no cloned axes<ul> <li><code>arc</code>: Arc plots</li> <li><code>circos</code>: Circos plots</li> <li><code>parallel</code>: Parallel coordinate plots</li> </ul> </li> <li>Graph visualizations with cloned axes<ul> <li><code>hive</code>: Hive plots</li> <li><code>matrix</code>: Matrix plots</li> </ul> </li> </ul> <p>The intent for this level of API is to provide a single function call that enables users to draw a graph to screen.</p>"},{"location":"developers/architecture/#intended-usage-example","title":"Intended usage example","text":"<pre><code>import nxviz as nv\nax = nv.hive(G, group_by=\"group\", sort_by=\"value\", node_color_by=\"value\")\n</code></pre>"},{"location":"developers/architecture/#medium-level","title":"Medium Level","text":"<p>At the medium level API, users interact with node layout and plotting functions in <code>nxviz.nodes</code> as well as edge drawing functions in <code>nxviz.edges</code>. Mostly it provides a way to compose node rendering and edge rendering.</p> <p>Mapping from quantitative or qualitative data is still done by nxviz's built-in default functions, and can't be changed at this level.</p>"},{"location":"developers/architecture/#intended-usage-example_1","title":"Intended usage example","text":"<p>Here is an example of how one would use the mid-level API.</p> <pre><code>from nxviz import nodes, edges\n\npos = nodes.circos(G, group_by=\"group\", sort_by=\"value\", color_by=\"group\")\nedges.circos(G, pos, alpha_by=\"edge_value\")\n</code></pre>"},{"location":"developers/architecture/#low-level","title":"Low Level","text":"<p>At the low level API, <code>nxviz</code> provides users with the maximum amount of control over node and edge styling. Here, instead of passing graph objects into the plotting and layout functions, users interact with node and edge tables.</p> <p>For node plotting, the steps are:</p> <ol> <li>Obtain the node table</li> <li>Using the node table, obtain the node positions using a node layout function.</li> <li>Using the node table, obtain node color, transparency, and sizes based on node metadata.</li> <li>Finally, obtain the matplotlib patches, and add them to the plot.</li> </ol> <p>For edge plotting, the steps are:</p> <ol> <li>Obtain the edge table</li> <li>Using the edge table, obtain the edge color, transparency and line widths based on edge metadata.</li> <li>Finally, obtain the matplotlib patches, and add them to the plot.</li> </ol>"},{"location":"developers/architecture/#intended-usage-example_2","title":"Intended usage example","text":"<p>Here's an example of how one would use the low-level API.</p> <pre><code>from nxviz import lines\n\nax = plt.gca()\n\n##### Part 1: Nodes #####\n# 1. Obtain node table\nnt = utils.node_table(G)\n\n# 2. Obtain positions using node table.\npos = layouts.circos(nt, group_by=\"group\", sort_by=\"value\")\n\n# 3. Obtain node styles\nnode_color = group_colormap(nt[\"group\"])\nalpha = nodes.transparency(nt, alpha_by=None)\nsize = nodes.node_size(nt, \"value\")\n\n# 4. Obtain patches styled correctly and add them to matplotlib axes.\npatches = nodes.node_glyphs(\n    nt, pos, node_color=node_color, alpha=alpha, size=size\n)\nfor patch in patches:\n    ax.add_patch(patch)\n\n##### Part 2: Edges #####\n# 1. Obtain edge table\net = utils.edge_table(G)\n\n# 2. Obtain edge styling.\nedge_color = edges.edge_colors(et, nt=None, color_by=None, node_color_by=None)\nlw = np.sqrt(et[\"edge_value\"])\nalpha = edges.transparency(et, alpha_by=None)\n\n# 3. Obtain edge patches styled and add them to matplotlib axes.\npatches = lines.circos(\n    et, pos, edge_color=edge_color, alpha=alpha, lw=lw, aes_kw={\"fc\": \"none\"}\n)\nfor patch in patches:\n    ax.add_patch(patch)\n</code></pre>"},{"location":"developers/architecture/#plotting-utilities","title":"Plotting utilities","text":"<p>We include some plotting utilities to make composing new plots together a bit easier. These functions are located in the <code>nxviz.plots</code> module. These include functions to rescale matplotlib axes (<code>plots.rescale()</code>), and despine and re-spine the axes objects (<code>plots.despine()</code> and <code>plots.respine()</code>).</p>"},{"location":"developers/architecture/#annotations","title":"Annotations","text":"<p>The core node and edge drawing functions can be composed with a variety of annotations onto the axes. These are all located in the <code>nxviz.annotate</code> module. For example, if one wants to add grouping annotations onto a Circos plot, one would use <code>annotate.circos_group</code>. Or if one wants to add in group block diagonals to the Matrix plot, one would call <code>annotate.matrix_block</code>.</p>"},{"location":"developers/architecture/#visual-encodings","title":"Visual Encodings","text":"<p>The default functions for mapping data to visual properties of node and edges are located in the <code>nxviz.nodes</code> and <code>nxviz.edges</code> modules. Underneath the hood, however, they call on functions in the <code>encodings</code> module.</p> <p>The pattern here is to produce an iterable of colors that correspond to each node and edge, done in a data-driven fashion. Underneath the hood, for code conciseness, we take advantage of the pandas DataFrame and Series APIs.</p>"},{"location":"developers/architecture/#geometry","title":"Geometry","text":"<p>The <code>nxviz.polcart</code> and <code>nxviz.geometry</code> modules give us convenience functions for calculating (x, y) coordinates from polcar coordinates and doing trigonometric calculations. (These are heavily used in plots with circular layouts, such as the Circos and Hive plots.)</p>"},{"location":"developers/architecture/#utils","title":"Utils","text":"<p>The <code>nxviz.utils</code> module is a catch-all for utility functions that don't fall into the aforementioned categories. For example, the node and edge table functions (<code>utils.node_table(G)</code> and <code>utils.edge_table(G)</code>), which construct the pandas DataFrame versions of the node set and edge set, are located in there. Because grouping and sorting nodes are intrinsic to constructing rational graph visualizations, the function <code>utils.group_and_sort(nt)</code> is also provided in there. Finally, there are utilities for automatically inferring whether a column of data is categorical, ordinal, or continuous based on data types and ranges. (That is used for identifying colormaps to be used for a particular data.)</p>"},{"location":"developers/contributing/","title":"How to contribute","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"developers/contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"developers/contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/ericmjl/nxviz/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>A minimally reproducible example (a.k.a. reprex) to reproduce the bug.</li> </ul>"},{"location":"developers/contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"developers/contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"developers/contributing/#write-documentation","title":"Write Documentation","text":"<p>nxviz could always use more documentation, whether as part of the official nxviz docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"developers/contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/ericmjl/nxviz/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul> <p>Because nxviz is currently maintained by volunteers and has no fiscal support, any feature requests will be prioritized according to what maintainers encounter as a need in our day-to-day jobs. Please temper expectations accordingly.</p>"},{"location":"developers/devguide/","title":"Development Guide","text":""},{"location":"developers/new-plots/","title":"Developing new plots","text":"<pre><code>%config InlineBackend.figure_format = 'retina'\n%load_ext autoreload\n%autoreload 2\n</code></pre> <pre><code>from random import choice\n\nimport networkx as nx\nimport numpy as np\n\nG = nx.erdos_renyi_graph(n=20, p=0.1)\nfor n, d in G.nodes(data=True):\n    G.nodes[n][\"group\"] = choice([\"a\", \"b\", \"c\"])\n    G.nodes[n][\"value\"] = np.random.exponential()\n\nnp.random.seed(44)\nfor u, v, d in G.edges(data=True):\n    G.edges[u, v][\"edge_value\"] = np.random.exponential()\n</code></pre> <pre><code>from typing import Hashable\n\nimport pandas as pd\n\nfrom nxviz.utils import group_and_sort\n\n\n# Just the skeleton first!\ndef matrix_layout(\n    nt: pd.DataFrame, group_by: Hashable = None, sort_by: Hashable = None\n):\n    nt = group_and_sort(nt=nt, group_by=group_by, sort_by=sort_by)\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> <p>With a matrix plot, our goal is to place nodes along the x- and y-axis. It's a bit like the hive plot with cloned axes.</p> <p>See the code annotations for the logic.</p> <pre><code># Filling in the x,y positions dictionary.\ndef matrix_layout(\n    nt: pd.DataFrame,\n    group_by: Hashable = None,\n    sort_by: Hashable = None,\n    axis=\"x\",\n):\n    # Nodes should be grouped and sorted before we begin assigning coordinates.\n    nt = group_and_sort(node_table=nt, group_by=group_by, sort_by=sort_by)\n\n    # We are eventually going to return this pos dictionary.\n    pos = dict()\n\n    # Loop over each of the rows, and assign x, y coordinates in order of them being grouped and sorted.\n    for i, (node, data) in enumerate(nt.iterrows()):\n        x = (i + 1) * 2\n        y = 0\n\n        if axis == \"y\":\n            x, y = y, x\n        pos[node] = np.array([x, y])\n    return pos\n</code></pre> <p>Now that we have the positions implemented, let's see what they look like.</p> <pre><code>from nxviz import layouts\nfrom nxviz.utils import node_table\n\nnt = node_table(G)\npos_x = matrix_layout(nt, group_by=\"group\", sort_by=\"value\")\npos_y = matrix_layout(nt, group_by=\"group\", sort_by=\"value\", axis=\"y\")\n</code></pre> <pre><code>pd.DataFrame(pos_x).T\n</code></pre> 0 1 11 2 0 14 4 0 19 6 0 17 8 0 3 10 0 7 12 0 10 14 0 8 16 0 6 18 0 12 20 0 2 22 0 4 24 0 13 26 0 15 28 0 1 30 0 16 32 0 18 34 0 5 36 0 0 38 0 9 40 0 <pre><code>pd.DataFrame(pos_y).T\n</code></pre> 0 1 11 0 2 14 0 4 19 0 6 17 0 8 3 0 10 7 0 12 10 0 14 8 0 16 6 0 18 12 0 20 2 0 22 4 0 24 13 0 26 15 0 28 1 0 30 16 0 32 18 0 34 5 0 36 0 0 38 9 0 40 <p>Now, we can worry about the glyphs being drawn to screen. We will follow the logic for the mid-level API. There is a <code>draw</code> function that we can take advantage of to make it happen.</p> <pre><code>from functools import partial\n\nfrom nxviz import nodes\n</code></pre> <pre><code>matrix = partial(\n    nodes.draw, layout_func=matrix_layout, group_by=None, sort_by=None\n)\npos_x = matrix(G)\npos_y = matrix(G, layout_kwargs=dict(axis=\"y\"))\n</code></pre> <p>Not bad! We're off to a good start. This looks ugly, but upon inspection, its' because the aspect ratio isn't that good. We can fix this.</p> <pre><code>from nxviz.plots import aspect_equal, despine\n\nmatrix = partial(\n    nodes.draw, layout_func=matrix_layout, group_by=None, sort_by=None\n)\npos_x = matrix(G)\npos_y = matrix(G, layout_kwargs=dict(axis=\"y\"))\n\naspect_equal()\ndespine()\n</code></pre> <p>Now that's looking good! We have a square matrix, just as we expected.</p> <pre><code>from nxviz import edges\n\nmatrix = partial(\n    nodes.draw, layout_func=matrix_layout, group_by=None, sort_by=None\n)\npos_x = matrix(G)\npos_y = matrix(G, layout_kwargs=dict(axis=\"y\"))\nedges.hive(G, pos_x, pos_cloned=pos_y, curves=False)\n</code></pre> <p>However, the spirit of a matrix plot is to fill in an <code>n-by-n</code> matrix. Thus, we should actually be using a custom implementation of edges that draws in a circle glyph where needed.</p> <p>The matrix \"lines\" function will follow the API of the functions in the <code>nxviz.lines</code> file. Lines are in quotes because we're not technically writing out lines. :)</p> <pre><code>from typing import Dict, Iterable\n\nfrom matplotlib.patches import Circle\n\n\ndef matrix_lines(\n    et,\n    pos,\n    pos_cloned,\n    edge_color: Iterable,\n    alpha: Iterable,\n    lw: Iterable,\n    aes_kw: Dict,\n):\n    patches = []\n    for r, d in et.iterrows():\n        start = d[\"source\"]\n        end = d[\"target\"]\n        x_start, y_start = pos_y[start]\n        x_end, y_end = pos[end]\n\n        x, y = (max(x_start, y_start), max(x_end, y_end))\n        kw = {\n            \"fc\": edge_color[r],\n            \"alpha\": alpha[r],\n            \"radius\": lw[r],\n            \"zorder\": 10,\n        }\n        kw.update(aes_kw)\n        patch = Circle(xy=(x, y), **kw)\n        patches.append(patch)\n    return patches\n\n\nmatrix_edges = partial(edges.draw, lines_func=matrix_lines)\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(4, 4))\npos_x = matrix(G, group_by=\"group\", color_by=\"value\", sort_by=\"value\")\npos_y = matrix(\n    G,\n    group_by=\"group\",\n    color_by=\"value\",\n    sort_by=\"value\",\n    layout_kwargs=dict(axis=\"y\"),\n)\nedges.matrix(G, pos_x, pos_cloned=pos_y, alpha_by=\"edge_value\")\n\ndespine()\naspect_equal()\n</code></pre> <pre><code>from nxviz import annotate\n\nfig, ax = plt.subplots(figsize=(4, 4))\npos_x = matrix(G, group_by=\"group\", color_by=\"group\", sort_by=\"value\")\npos_y = matrix(\n    G,\n    group_by=\"group\",\n    color_by=\"group\",\n    sort_by=\"value\",\n    layout_kwargs=dict(axis=\"y\"),\n)\nmatrix_edges(G, pos_x, pos_cloned=pos_y, alpha_by=\"edge_value\")\n\n# Gives us a colorbar next to the chart.\nannotate.node_colormapping(G, color_by=\"group\")\n\ndespine()\naspect_equal()\n</code></pre> <pre><code>from nxviz import annotate\n\nfig, ax = plt.subplots(figsize=(4, 4))\npos_x = matrix(G, group_by=\"group\", color_by=\"value\", sort_by=\"value\")\npos_y = matrix(\n    G,\n    group_by=\"group\",\n    color_by=\"value\",\n    sort_by=\"value\",\n    layout_kwargs=dict(axis=\"y\"),\n)\nmatrix_edges(G, pos_x, pos_cloned=pos_y, encodings_kwargs={\"alpha_scale\": 5})\n\n# Gives us a colorbar next to the chart.\nannotate.node_colormapping(G, color_by=\"value\")\n\ndespine()\naspect_equal()\n</code></pre> <pre><code>from nxviz.plots import respine\n\n\ndef matrix_group(G, group_by, ax=None, offset=-3.0, xrotation=0, yrotation=0):\n    if ax is None:\n        ax = plt.gca()\n    nt = node_table(G)\n    group_sizes = nt.groupby(group_by).apply(lambda df: len(df))\n    proportions = group_sizes / group_sizes.sum()\n    midpoint = proportions / 2\n    starting_positions = proportions.cumsum() - proportions\n    label_positions = (starting_positions + midpoint) * len(G) * 2\n    label_positions += 1\n\n    for label, position in label_positions.to_dict().items():\n        # Plot the x-axis labels\n        y = offset\n        x = position\n        ax.annotate(label, xy=(x, y), ha=\"center\", va=\"center\", rotation=0)\n\n        # Plot the y-axis labels\n        x = offset\n        y = position\n        ax.annotate(label, xy=(x, y), ha=\"center\", va=\"center\", rotation=90)\n\n\nfig, ax = plt.subplots(figsize=(4, 4))\npos_x = matrix(G, group_by=\"group\", color_by=\"group\", sort_by=\"value\")\npos_y = matrix(\n    G,\n    group_by=\"group\",\n    color_by=\"group\",\n    sort_by=\"value\",\n    layout_kwargs=dict(axis=\"y\"),\n)\nmatrix_edges(G, pos_x, pos_cloned=pos_y, alpha_by=\"edge_value\")\n\n# Gives us a colorbar next to the chart.\nmatrix_group(G, group_by=\"group\")\n\ndespine()\naspect_equal()\n</code></pre> <pre>\n<code>/tmp/ipykernel_2412/3909858447.py:8: DeprecationWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  group_sizes = nt.groupby(group_by).apply(lambda df: len(df))\n</code>\n</pre> <pre><code>fig, ax = plt.subplots(figsize=(4, 4))\npos_x = matrix(G, group_by=\"group\", color_by=\"group\", sort_by=\"value\")\npos_y = matrix(\n    G,\n    group_by=\"group\",\n    color_by=\"group\",\n    sort_by=\"value\",\n    layout_kwargs=dict(axis=\"y\"),\n)\nmatrix_edges(G, pos_x, pos_cloned=pos_y, alpha_by=\"edge_value\")\n\nmatrix_group(G, group_by=\"group\")\n\nrespine()\naspect_equal()\n\n##### FUNCTION STARTS\n\nfrom matplotlib.patches import Rectangle\n\nfrom nxviz import encodings as aes\nfrom nxviz import utils\n\nnt = node_table(G)\ngroup_by = \"group\"\ncolor_by = \"group\"\n\n\ndef matrix_block(G, group_by, color_by=None, ax=None):\n\n    group_sizes = nt.groupby(group_by).apply(lambda df: len(df)) * 2\n    starting_positions = group_sizes.cumsum() + 1 - group_sizes\n    starting_positions\n\n    colors = pd.Series([\"black\"] * len(group_sizes), index=group_sizes.index)\n    if color_by:\n        color_data = pd.Series(group_sizes.index, index=group_sizes.index)\n        colors = aes.data_color(color_data, color_data)\n    # Generate patches first\n    patches = []\n    for label, position in starting_positions.to_dict().items():\n        xy = (position, position)\n        width = height = group_sizes[label]\n\n        patch = Rectangle(\n            xy, width, height, zorder=0, alpha=0.1, facecolor=colors[label]\n        )\n        patches.append(patch)\n\n    if ax is None:\n        ax = plt.gca()\n    # Then add patches in.\n    for patch in patches:\n        ax.add_patch(patch)\n\n\nmatrix_block(G, group_by=group_by, color_by=color_by)\n##### FUNCTION ENDS\ndespine()\n</code></pre> <pre>\n<code>/tmp/ipykernel_2412/3909858447.py:8: DeprecationWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  group_sizes = nt.groupby(group_by).apply(lambda df: len(df))\n/tmp/ipykernel_2412/3127646949.py:31: DeprecationWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  group_sizes = nt.groupby(group_by).apply(lambda df: len(df)) * 2\n</code>\n</pre> <pre><code>import nxviz as nv\n\nax = nv.matrix(G)\n</code></pre> <pre><code>ax = nv.matrix(\n    G, group_by=\"group\", node_color_by=\"group\", edge_alpha_by=\"edge_value\"\n)\nannotate.matrix_block(G, group_by=\"group\", color_by=\"group\")\n</code></pre>"},{"location":"developers/new-plots/#implementing-a-new-plot","title":"Implementing a new plot","text":"<p>We'll show you how to implement a new plot using the nxviz's layered API.</p> <p>As an example, we'll show you how the design process works for the matrix plot.</p>"},{"location":"developers/new-plots/#example-graph","title":"Example graph","text":"<p>As always, we'll need an example graph to anchor our notebook.</p>"},{"location":"developers/new-plots/#implement-node-layout","title":"Implement node layout","text":"<p>We first have to worry about how the nodes are placed. Therefore, we need a node layout function.</p> <p>All node layout functions accept the following arguments:</p> <ul> <li>a node table <code>nt</code>,</li> <li>the key to <code>group_by</code></li> <li>the key to <code>sort_by</code> (optionally)</li> <li>any other relevant keyword arguments</li> </ul> <p>With the matrix plot layout, from thinking about how the nodes should be laid out, we will probably arrive at the conclusion that grouping and sorting are technically optional and not intrinsic to the layout. If that's not obvious at first glance, please think about it, you'll probably arrive at the same conclusion!</p> <p>They then return the x, y coordinates to place nodes on.</p> <p>The exact glyphs and their styles are out-of-bounds! Therefore, don't worry about them just yet.</p>"},{"location":"developers/new-plots/#drawing-edges","title":"Drawing edges","text":"<p>For edges, we could take advantage of hive plot's lines. That would make the chart look interesting... like one of those arts and crafts tapestries we might have made when we were younger.</p>"},{"location":"developers/new-plots/#annotations","title":"Annotations","text":"<p>We may wish to annotate the plot with additional information. For example, we might want to annotate the node values. This is doable using the same annotation tools available to us in nxviz.</p>"},{"location":"developers/new-plots/#node-color-by-group","title":"Node color by group","text":""},{"location":"developers/new-plots/#node-color-by-value","title":"Node color by value","text":""},{"location":"developers/new-plots/#annotating-group-identity","title":"Annotating group identity","text":"<p>The group identities can also be annotated on the chart itself. Here's how the <code>matrix_group</code> annotation function is implemented.</p>"},{"location":"developers/new-plots/#annotate-matrix-blocks","title":"Annotate matrix blocks","text":"<p>We could also annotate the matrix blocks using the exact same logic.</p> <p>Matrix blocks are defined as the blocks of nodes in the same group, so this only applies to graphs for which the nodes can be grouped together.</p>"},{"location":"developers/new-plots/#high-level-api","title":"High level API","text":"<p>Of course, in showing you how to implement a matrix plot from scratch, we took the code and shoved it into our high-level API. Here's a few examples of how it's used.</p>"},{"location":"examples/arc_node_labels/","title":"Arc Node Labels","text":"<pre><code>from random import randint\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nimport nxviz as nv\nfrom nxviz import annotate\n\nG = nx.barbell_graph(m1=10, m2=3)\nfor n, d in G.nodes(data=True):\n    G.nodes[n][\"group\"] = randint(0, 3)\nG = nx.relabel_nodes(G, {i: \"long name #\" + str(i) for i in range(len(G))})\n\nnv.arc(G, group_by=\"group\", node_color_by=\"group\")\nannotate.arc_labels(G, group_by=\"group\", layout=\"standard\")\n# The standard labels take up more space, so we will have to increase the\n# padding a bit. 5% on all sides works well here.\nplt.tight_layout(rect=(0.05, 0.05, 0.95, 0.95))\nplt.show()\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre>"},{"location":"examples/arc_node_labels/#annotating-node-labels-on-arc-plots","title":"Annotating Node Labels on Arc Plots","text":"<p>Author: Alireza Hosseini</p>"},{"location":"examples/circos_node_labels/","title":"Circos Node Labels","text":"<pre><code>from random import randint\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nimport nxviz as nv\nfrom nxviz import annotate\n\nG = nx.erdos_renyi_graph(n=30, p=0.1)\nfor n, d in G.nodes(data=True):\n    G.nodes[n][\"group\"] = randint(0, 5)\nG = nx.relabel_nodes(G, {i: \"long name #\" + str(i) for i in range(len(G))})\n\nnv.circos(G, group_by=\"group\", node_color_by=\"group\")\nannotate.circos_labels(G, group_by=\"group\", layout=\"rotate\")\n# The rotated labels take up more space, so we will have to increase the\n# padding a bit. 5% on all sides works well here.\nplt.tight_layout(rect=(0.05, 0.05, 0.95, 0.95))\nplt.show()\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> <pre><code>G = nx.erdos_renyi_graph(n=30, p=0.1)\nfor n, d in G.nodes(data=True):\n    G.nodes[n][\"group\"] = randint(0, 5)\nG = nx.relabel_nodes(G, {i: \"long name #\" + str(i) for i in range(len(G))})\n\nnv.circos(G, group_by=\"group\", node_color_by=\"group\")\nannotate.circos_labels(G, group_by=\"group\", layout=\"numbers\")\n# The numbered labels take up more space, so we will have to increase the\n# padding a bit. 15% on all sides works well here.\nplt.tight_layout(rect=(0.15, 0.15, 0.85, 0.85))\nplt.show()\n</code></pre> <pre><code>from itertools import cycle\n# 14 categories\ncategories = [\n    \"sun\",\n    \"moon\",\n    \"stars\",\n    \"cloud\",\n    \"wheel\",\n    \"box\",\n    \"plant\",\n    \"chair\",\n    \"slippers\",\n    \"tablet\",\n    \"laptop\",\n    \"dishwasher\",\n    \"bicycle\",\n    \"piano\",\n    \"laptop\",\n]\n\n# 20 colors - providing an uneven list on purpose\npalette = [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#279e68\",\n    \"#d62728\",\n    \"#aa40fc\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#b5bd61\",\n    \"#17becf\",\n    \"#aec7e8\",\n    \"#ffbb78\",\n    \"#98df8a\",\n    \"#ff9896\",\n    \"#c5b0d5\",\n    \"#c49c94\",\n    \"#f7b6d2\",\n    \"#dbdb8d\",\n    \"#9edae5\",\n    \"#ad494a\",\n    \"#8c6d31\",\n]\n\ncategorical = cycle(categories[0:4]) # max 4 distinct categories\ncategories[0:4]\n# ['sun', 'moon', 'stars', 'cloud']\nmany_categorical = cycle(categories) # up to 14\n\nn = 71\np = 0.01\nG = nx.erdos_renyi_graph(n=n, p=p)\n\nlegend_kwargs = {\n        \"ncol\": 1,\n        \"bbox_to_anchor\": (1, 0.5),\n        \"frameon\": False,\n        \"loc\": \"center left\",\n    }\n\nfor n in G.nodes():\n    G.nodes[n][\"group1\"] = next(categorical)\n    G.nodes[n][\"group2\"] = next(many_categorical) # up to 14\nfor u, v in G.edges():\n    G.edges[u, v][\"edge_group1\"] = next(categorical)\n    G.edges[u, v][\"edge_group2\"] = next(many_categorical) # up to 14\n    G.edges[u, v][\"thickness\"] = 3  # just to be able see the edge colours later\n</code></pre> <p>Current default behavior</p> <pre><code>nv.circos(G, group_by=\"group1\", node_color_by=\"group1\")\nannotate.node_colormapping(G, color_by=\"group1\", legend_kwargs=legend_kwargs)\n</code></pre> <p>Now we can manusally specify the node colors:</p> <pre><code>nv.circos(G, group_by=\"group1\", node_color_by=\"group1\", node_palette=palette[:4]) # specify 4 colors for 4 groups\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <p>now with more than 12 categories (14), and a long color palette (20 colors)</p> <pre><code>nv.circos(G, group_by=\"group2\", node_color_by=\"group2\", node_palette=palette)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <p>same as above but limit to 7 colors - colors start to cycle if palette is provided as a list.</p> <pre><code>nv.circos(G, group_by=\"group2\", node_color_by=\"group2\", node_palette=palette[:7])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <p>palette provides as a dictionary</p> <pre><code>pal = {'moon':'red', 'stars':'yellow', 'sun':'black', 'cloud':'blue'}\nnv.circos(G, group_by=\"group1\", node_color_by=\"group1\", node_palette=pal)\nannotate.node_colormapping(G, color_by=\"group1\", palette=pal)\n</code></pre> <p>order of keys don't matter</p> <pre><code>pal = {'moon':'red', 'cloud':'pink', 'stars':'yellow', 'sun':'black'}\nnv.circos(G, group_by=\"group1\", node_color_by=\"group1\", node_palette=pal)\nannotate.node_colormapping(G, color_by=\"group1\", palette=pal)\n</code></pre> <p>can mix colors/hex codes</p> <pre><code>pal = ['pink', '#1f77B4', 'green', '#ff7f0e']\nnv.circos(G, group_by=\"group1\", node_color_by=\"group1\", node_palette=pal)\nannotate.node_colormapping(G, color_by=\"group1\", palette=pal)\n</code></pre> <p>swapping of order of colors in a list matters. But the plot should reflect this correctly - if you look up at the dictionary examples, the same order is preserved.</p> <pre><code>pal = ['pink', '#1f77B4', '#ff7f0e', 'green'] # swapped the order of the last two colours\nnv.circos(G, group_by=\"group1\", node_color_by=\"group1\", node_palette=pal)\nannotate.node_colormapping(G, color_by=\"group1\", palette=pal)\n</code></pre> <p>Can be used on edges as well:</p> <pre><code>ax = nv.circos(G, \n          group_by=\"group1\", \n          node_color_by = \"group1\", \n          edge_color_by = 'edge_group1', \n          node_palette = pal, \n          edge_palette = palette,\n          edge_lw_by = 'thickness',\n         )\nannotate.edge_colormapping(G, color_by=\"edge_group1\", palette=palette) # not quite sure how to make both node and edge legend appear\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/circos_node_labels/#annotating-circos-plot-node-labels","title":"Annotating Circos Plot Node Labels","text":"<p>This example set was contributed by Alireza Hosseini.</p>"},{"location":"examples/circos_node_labels/#custom-color-mapping-circos-nodes-and-edges","title":"Custom color mapping circos nodes and edges","text":"<p>This example shows how to customize the color mapping of nodes and edges in a Circos plot.</p> <p>The example is contributed by Kelvin Tuong.</p>"},{"location":"examples/geo/","title":"Geo Plot","text":"<pre><code>%config InlineBackend.figure_format = 'retina'\n%load_ext autoreload\n%autoreload 2\n</code></pre> <pre><code>import pickle\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nimport nxviz as nv\nfrom nxviz import edges, layouts, nodes, plots, utils, annotate\nfrom pyprojroot import here\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> <pre><code>with open(here() / \"docs/examples/divvy.pkl\", 'rb') as f:\n    G = pickle.load(f)\n\nG_new = G.copy()\nfor n1, n2, d in G.edges(data=True):\n    if d[\"count\"] &amp;lt; 150:\n        G_new.remove_edge(n1, n2)\n</code></pre> <pre><code>nt = utils.node_table(G_new)\npos = nodes.draw(\n    G_new,\n    layout_func=layouts.geo,\n    group_by=None,\n    sort_by=None,\n    color_by=\"dpcapacity\",\n    encodings_kwargs={\"size_scale\": 0.0015},\n)\nedges.line(G_new, pos)\nannotate.node_colormapping(G_new, color_by=\"dpcapacity\")\nplots.rescale(G)\nplots.aspect_equal()\nplots.despine()\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/.pixi/envs/docs/lib/python3.13/site-packages/matplotlib/patches.py:1648: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  center = (self.convert_xunits(self._center[0]),\n/home/runner/work/nxviz/nxviz/.pixi/envs/docs/lib/python3.13/site-packages/matplotlib/patches.py:1649: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  self.convert_yunits(self._center[1]))\n</code>\n</pre> <pre><code>from nxviz import annotate\nnv.geo(G_new, node_color_by=\"dpcapacity\")\nannotate.node_colormapping(G_new, color_by=\"dpcapacity\")\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/.pixi/envs/docs/lib/python3.13/site-packages/matplotlib/patches.py:1648: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  center = (self.convert_xunits(self._center[0]),\n/home/runner/work/nxviz/nxviz/.pixi/envs/docs/lib/python3.13/site-packages/matplotlib/patches.py:1649: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  self.convert_yunits(self._center[1]))\n</code>\n</pre>"},{"location":"examples/geo/#geo-plot","title":"Geo Plot","text":"<p>In this notebook, we will see how to create geographic graph visualizations using the mid-level and high-level APIs.</p>"},{"location":"examples/geo/#mid-level-api","title":"Mid-level API","text":""},{"location":"examples/geo/#high-level-api","title":"High-level API","text":""},{"location":"examples/matrix/","title":"Matrix Plot","text":"<pre><code>%config InlineBackend.figure_format = 'retina'\n%load_ext autoreload\n%autoreload 2\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy.random as npr\n\nimport nxviz as nv\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> <pre><code>G = nx.lollipop_graph(m=10, n=4)\nfor n, d in G.nodes(data=True):\n    G.nodes[n][\"degree\"] = nx.degree(G, n)\nax = nv.matrix(G, sort_by=\"degree\", node_color_by=\"degree\")\n</code></pre> <pre><code>nx.draw(G)\n</code></pre>"},{"location":"examples/matrix/#matrix-plot","title":"Matrix Plot","text":"<p>Here is an example of how to create a matrix plot.</p>"},{"location":"examples/matrix_node_labels/","title":"Matrix Node Labels","text":"<pre><code>from random import randint\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nimport nxviz as nv\nfrom nxviz import annotate\n\nG = nx.barbell_graph(m1=10, m2=3)\nfor n, d in G.nodes(data=True):\n    G.nodes[n][\"group\"] = randint(0, 3)\nG = nx.relabel_nodes(G, {i: \"long name #\" + str(i) for i in range(len(G))})\n\nfig, ax = plt.subplots(figsize=(10, 10))\nnv.matrix(G, group_by=\"group\", node_color_by=\"group\")\nannotate.matrix_labels(G, group_by=\"group\", layout=\"standard\")\n# the standard labels take up more space, so we will have to increase the\n# padding a bit. 5% on all sides works well here.\nplt.tight_layout(rect=(0.05, 0.05, 0.95, 0.95))\nplt.show()\n</code></pre> <pre>\n<code>/home/runner/work/nxviz/nxviz/nxviz/__init__.py:33: UserWarning: \nnxviz has a new API! Version 0.7.4 onwards, the old class-based API is being\ndeprecated in favour of a new API focused on advancing a grammar of network\ngraphics. If your plotting code depends on the old API, please consider\npinning nxviz at version 0.7.4, as the new API will break your old code.\n\nTo check out the new API, please head over to the docs at\nhttps://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it!\n\n(This deprecation message will go away in version 1.0.)\n\n  warnings.warn(\n</code>\n</pre> <pre><code>\n</code></pre>"},{"location":"examples/matrix_node_labels/#annotating-node-labels-on-matrix-plots","title":"Annotating Node Labels on Matrix Plots.","text":"<p>Author: Alireza Hosseini</p>"},{"location":"releases/v0.7.6/","title":"V0.7.6","text":""},{"location":"releases/v0.7.6/#version-076","title":"Version 0.7.6","text":"<p>This release introduces several improvements to the build system, project configuration, and continuous integration workflows, along with a few new features and bug fixes.</p>"},{"location":"releases/v0.7.6/#new-features","title":"New Features","text":"<ul> <li>Added <code>__all__</code> attribute to <code>__init__.py</code> for explicit module exports, specifying the public API including major plot types and the version module. (5e1682) (Eric Ma)</li> </ul>"},{"location":"releases/v0.7.6/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Refined test parameters and assertions for polar-cartesian conversion to improve numerical stability and accuracy. (be22b3) (Eric Ma)</li> <li>Updated GitHub Actions workflow to use <code>GITHUB_TOKEN</code> for <code>gh-pages</code>, replacing <code>GHPAGES_TOKEN</code> and removing unnecessary configurations. (8ac7a5) (Eric Ma)</li> </ul>"},{"location":"releases/v0.7.6/#deprecations","title":"Deprecations","text":"<ul> <li>Removed the <code>Makefile</code> from the repository as tasks are now managed through alternative methods. (5cf4de) (Eric Ma)</li> <li>Deleted the <code>.editorconfig</code> file to simplify repository configuration. (60eda6) (Eric Ma)</li> <li>Removed unused configuration files <code>.pyup.yml</code> and <code>.readthedocs.yml</code> from the repository. (c2d6c3) (Eric Ma)</li> </ul>"},{"location":"releases/v0.7.6/#other-changes","title":"Other Changes","text":"<ul> <li>Switched the build system from <code>setuptools</code> to <code>hatchling</code>, updating build-system requirements and removing the license field from project metadata. (49da26) (Eric Ma)</li> <li>Updated the license field in <code>pyproject.toml</code> to use a string value 'MIT', aligning with standard practices. (19e155) (Eric Ma)</li> <li>Added <code>.env</code> file to <code>.gitignore</code> to ensure sensitive environment variables are not tracked in version control. (90e0de) (Eric Ma)</li> <li>Updated the Black formatter version in the pre-commit configuration. (b386c9) (Eric Ma)</li> <li>Updated CI workflow job name for clarity, renaming 'Build conda environment' to 'Build documentation'. (075516) (Eric Ma)</li> <li>Updated release workflow to include <code>uv</code> binary installation and adjusted <code>pip install</code> command. (fad120) (Eric Ma)</li> </ul>"}]}